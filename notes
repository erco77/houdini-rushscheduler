    # Custom onStartCook logic. Returns True if started.
    #     ERCO: THIS RUNS WHEN FIRST WORK ITEM IS STARTED.
    #     This should:
    #        1) Maybe dump any previous rush job
    #        2) Stop any previous rush frame starter thread
    #        3) Clear the 'rush job started' flag, so a new job will be started
    #           the next time a workitem is started by "onSchedule"
    #        4) Return True regardless of what we do
    #
    # The following variables are available:
    # self          -  A reference to the current pdg.Scheduler instance
    # static        -  True if static cook
    # cook_set      -  Set of nodes to cook
    #
---
    # Custom onSchedule logic.
    #     ERCO: This runs to start new work items (Rush frames).
    #
    #     If a "rush frame starter" thread hasn't yet been started,
    #     start one:
    #         a) zero the rush frame cache array
    #         b) clear the thread lock for this scheduler node
    #         c) start a child thread to monitor the rush frame cache
    #
    #     Add the work item to the frame cache:
    #         a) acquire child thread lock
    #         b) add item to frame array
    #         c) release lock
    #
    #     Return that the item was scheduled (Succeeded)
    #
    #     CHILD THREAD
    #     ============
    #     Keeps watch on the 'work item cache' (rush frame cache), and as work items
    #     appear in it, will start a rush job (if there isn't one already), and adds
    #     rush frames to the job, one per work item found, then removes the item(s)
    #     from the cache so they aren't re-applied to the job. So the thread loop is:
    #
    #         1) Acquire a lock on the cache (rush frame cache/work item cache)
    #         2) For each work item in the cache:
    #                a) Write out a json file with the rush frame# in the file name
    #                   containing the env vars, command to run, etc
    #                b) Add rush frame for the work item, using either a monotonic
    #                   rush frame number, or use the work item id as the rush frame#
    #                c) Set the frame notes for the work item to be the work item's 'name'
    #                   so it appears in the irush Frames report
    #         3) Release lock
    #         4) Do a small 5 second sleep loop:
    #                a) Sleep 1/2 sec
    #                b) Check if parent cancelled us, and if so, stop thread
    #                c) loop
    #         5) Go to 1
    #
    # Returns pdg.ScheduleResult:
    #     CookCanceled     -- work item was canceled immediately, without being scheduled
    #     CookFailed       -- work item failed immediately, without being scheduled
    #     CookSucceeded    -- work item was marked as succeeded immediately
    #     Failed           -- Scheduling of the work item failed
    #     Succeeded        -- work item was successfully scheduled
    #     Deferred         -- work item was deferred and will be scheduled later
    #     FullDeferred     -- item deferred/will schedule later, no more schedule attempts
    #                         will be made from the set of ready items on the current tick.
    #
    # The following variables are available:
    # self          -  A reference to the current pdg.Scheduler instance
    # work_item     -  The pdg.WorkItem to schedule
----
DURING RUN

*** Generate Node (static):

    --- onStartCook
    --- onStopCook
    --- onTick

*** Cook Work Item:

    --- onTick
    --- onSchedule
    --- RUSH onSchedule:
	    PDG_ITEM_NAME: ropmantra1_ropfetch1_1
	PDG_RESULT_SERVER: 127.0.0.1:44825
	    PDG_ITEM_NAME: ropmantra1_ropfetch1_1
	      PDG_ITEM_ID: 1
		  PDG_DIR: /home/jparker/Desktop
		 PDG_TEMP: /home/jparker/Desktop/pdgtemp/136977
	    PDG_SCRIPTDIR: /home/jparker/Desktop/pdgtemp/136977/scripts

	 work_item id: 1
       work_item name: ropmantra1_ropfetch1_1
      work_item label: ropmantra1_ropfetch1_1

	EXECUTING: "/opt/hfs20.0.590/bin/hython" "/home/jparker/Desktop/pdgtemp/136977/scripts/rop.py" json
    --- onStopCook

----

== Reporting Cook Error Messages ==

   import CookError             -- cook exception

    * The following is run from onTick() to trap an exception:

        except Exception:
            # Don't raise exception which will kill timer thread
            self.cookError('{}'.format(traceback.format_exc(1)))


    * The following run from onTick() to advertise an error
      and cancel the cook scheduling:

        self.cookError('Returning cancel cook due to MQ Relay error: {}'.format(mq_error))
        return tickResult.SchedulerCancelCook


    * The following is run from onTick():

        except Exception as e:
            [..]
            fail_msg = ('Failed to connect to MQ server at {}:{} with error:\n"{}"!\n'
                        'Try disabling network firewall or allow PDG MQ ports in '
                        'firewall setting.').format(mqaddr, relay_port, str(e))
            raise CookError(fail_msg)
                  ^^^^^^^^^^^^^^^^^^^

----
Notes for when writing onTick() code:
        # ERCO: May need:
        #       with attrib_owner.lockAttributes():
        #            attrib_owner.setIntAttrib("example", 10)
        #       See: 
        #           [1] https://www.sidefx.com/docs/houdini/tops/schedulers_callbacks.html
        #           [2] https://www.sidefx.com/docs/houdini/tops/pdg/WorkItem.html#lockAttributes
        #
        #       From [1]:
        #        ------------------------------------------------------------------------------------------
        #        >> Warning
        #        >>     The only callback that can safely write work item attributes is onSchedule.
        #        >>     If you want to add attributes to a work item in the onTick callback,
        #        >>     you need to use the pdg.WorkItem.lockAttributes in order to safely modify the work item.
        #        >>     Additionally, your scheduler node should only keep references to work items
        #        >>     that are actively running. Once your scheduler notifies PDG that a work item
        #        >>     has succeeded or failed, it should no longer hold a reference to that work item.
        #        ------------------------------------------------------------------------------------------

----
# if not os.path.isdir(status_dir):
#     # Create status dir if it doesn't exist
#     print("--- rush-render:  Creating status dir: %s" % status_file)
#     try: os.mkdir(status_dir, 0o777)    # might fail if another render did it already
#     except: pass                        # ignore on fail
